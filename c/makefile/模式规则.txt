一、模式规则介绍
模式规则中，至少在规则的目标定义中要包含"%"，否则，就是一般的规则。目标中的
"%"定义表示对文件名的匹配，"%"表示长度任意的非空字符串。例如："%.c"表示以".c"结
尾的文件名（文件名的长度至少为 3），而"s.%.c"则表示以"s."开头，".c"结尾的文件名（文
件名的长度至少为 5）。

如果"%"定义在目标中，那么，目标中的"%"的值决定了依赖目标中的"%"的值，也就是
说，目标中的模式的"%"决定了依赖目标中"%"的样子。例如有一个模式规则如下：
%.o : %.c ; <command ......>

其含义是，指出了怎么从所有的[.c]文件生成相应的[.o]文件的规则。如果要生成的目标
是"a.o b.o"，那么"%c"就是"a.c b.c"。

一旦依赖目标中的"%"模式被确定，那么，make 会被要求去匹配当前目录下所有的文件名，
一旦找到，make 就会规则下的命令，所以，在模式规则中，目标可能会是多个的，如果有
模式匹配出多个目标，make 就会产生所有的模式目标，此时，make 关心的是依赖的文件名
和生成目标的命令这两件事。

下面这个例子表示了,把所有的[.c]文件都编译成[.o]文件.

%.o : %.c
$(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@

其中，"$@"表示所有的目标的挨个值，"$<"表示了所有依赖目标的挨个值。这些奇怪的
变量我们叫"自动化变量"，后面会详细讲述。

下面的这个例子中有两个目标是模式的：

%.tab.c %.tab.h: %.y
bison -d $<


三、自动化变量
$@
表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，"$@"就是匹配于
目标中模式定义的集合。

$%
仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是"foo.a
(bar.o)"，那么，"$%"就是"bar.o"，"$@"就是"foo.a"。如果目标不是函数库文件（Unix
下是[.a]，Windows 下是[.lib]），那么，其值为空。

$<
依赖目标中的第一个目标名字。如果依赖目标是以模式（即"%"）定义的，那么"$<"将
是符合模式的一系列的文件集。注意，其是一个一个取出来的。

$?
所有比目标新的依赖目标的集合。以空格分隔。

$^
所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量
会去除重复的依赖目标，只保留一份。

$+
这个变量很像"$^"，也是所有依赖目标的集合。只是它不去除重复的依赖目标。

$*
这个变量表示目标模式中"%"及其之前的部分。如果目标是"dir/a.foo.b"，并且目标的
模式是"a.%.b"，那么，"$*"的值就是"dir/a.foo"。这个变量对于构造有关联的文件名是比
较有较。如果目标中没有模式的定义，那么"$*"也就不能被推导出，但是，如果目标文件的
后缀是 make 所识别的，那么"$*"就是除了后缀的那一部分。例如：如果目标是"foo.c"，因
为".c"是 make 所能识别的后缀名，所以，"$*"的值就是"foo"。这个特性是 GNU make 的，
很有可能不兼容于其它版本的 make，所以，你应该尽量避免使用"$*"，除非是在隐含规则
或是静态模式中。如果目标中的后缀是 make 所不能识别的，那么"$*"就是空值。

当你希望只对更新过的依赖文件进行操作时，"$?"在显式规则中很有用，例如，假设有
一个函数库文件叫"lib"，其由其它几个 object 文件更新。那么把 object 文件打包的比较
有效率的 Makefile 规则是：

lib : foo.o bar.o lose.o win.o
ar r lib $?

在上述所列出来的自动量变量中。四个变量（$@、$<、$%、$*）在扩展时只会有一个文
件，而另三个的值是一个文件列表。这七个自动化变量还可以取得文件的目录名或是在当前
目录下的符合模式的文件名，只需要搭配上"D"或"F"字样。这是 GNU make 中老版本的特性，
在新版本中，我们使用函数"dir"或"notdir"就可以做到了。"D"的含义就是 Directory，就
是目录，"F"的含义就是 File，就是文件。

下面是对于上面的七个变量分别加上"D"或是"F"的含义：

$(@D)
	表示"$@"的目录部分（不以斜杠作为结尾），如果"$@"值是"dir/foo.o"，那么"$(@D)"
	就是"dir"，而如果"$@"中没有包含斜杠的话，其值就是"."（当前目录）。

	$(@F)
	表示"$@"的文件部分，如果"$@"值是"dir/foo.o"，那么"$(@F)"就是"foo.o"，"$(@F)"
	相当于函数"$(notdir $@)"。

	"$(*D)"
	"$(*F)"
	和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子，"$(*D)"
	返回"dir"，而"$(*F)"返回"foo"

	"$(%D)"
	"$(%F)"
	分别表示了函数包文件成员的目录部分和文件部分。这对于形同"archive(member)"形
	式的目标中的"member"中包含了不同的目录很有用。

	"$(<D)"
	"$(<F)"
	分别表示依赖文件的目录部分和文件部分。

	"$(^D)"
	"$(^F)"
	分别表示所有依赖文件的目录部分和文件部分。（无相同的）

"$(+D)"
"$(+F)"
分别表示所有依赖文件的目录部分和文件部分。（可以有相同的）

"$(?D)"
"$(?F)"
分别表示被更新的依赖文件的目录部分和文件部分。

最后想提醒一下的是，对于"$<"，为了避免产生不必要的麻烦，我们最好给$后面的那
个特定字符都加上圆括号，比如，"$(<)"就要比"$<"要好一些。

还得要注意的是，这些变量只使用在规则的命令中，而且一般都是"显式规则"和"静态
模式规则"（参见前面"书写规则"一章）。其在隐含规则中并没有意义。

